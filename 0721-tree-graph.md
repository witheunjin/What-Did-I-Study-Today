# 2020.07.21 Tue

**ğŸ“šê³µë¶€í•œ ê±° List**ğŸ“š

- ì½”ë”©ì¸í„°ë·°ì™„ì „ë¶„ì„ - íŠ¸ë¦¬ì™€ ê·¸ë˜í”„ ì´ë¡  ì •ë¦¬
- ì¢…ë§Œë¶ - 21. íŠ¸ë¦¬ì˜ êµ¬í˜„ê³¼ ìˆœíšŒ ('ìš”ìƒˆ' ì œì™¸)
- ì¢…ë§Œë¶ - 22. ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬ ('íŠ¸ë¦½', 'ì‚½ì… ì •ë ¬ ë’¤ì§‘ê¸°' ì œì™¸)
- ì¢…ë§Œë¶ - 27. ê·¸ë˜í”„ì˜ í‘œí˜„ê³¼ ì •ì˜
- ì¢…ë§Œë¶ - 28. ê·¸ë˜í”„ì˜ ê¹Šì´ ìš°ì„  íƒìƒ‰

----

## [ì¢…ë§Œë¶] íŠ¸ë¦¬ì˜ êµ¬í˜„ê³¼ ìˆœíšŒ

#### âŒ¨ï¸íŠ¸ë¦¬ì˜ ë…¸ë“œë¥¼ í‘œí˜„í•˜ëŠ” ê°ì²´

```c++
struct TreeNode {
  string label; //value
  TreeNode* parent;
  vector<TreeNode*> children;
};
```

### íŠ¸ë¦¬ì˜ ìˆœíšŒ(traversal)

- ëª¨ë“  ë…¸ë“œë¥¼ ìˆœíšŒí•˜ë©° ë°ì´í„° ì¶œë ¥
- íŠ¸ë¦¬ì˜ ë†’ì´êµ¬í•˜ê¸°(height(tree) = max(depths(subtree)))
- ìˆœíšŒ ì¢…ë¥˜ : `pre-order`(VLR), `in-order`(LVR), `post-order`(LRV)

#### âŒ¨ï¸íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©° ëª¨ë“  ë…¸ë“œì— í¬í•¨ëœ ê°’ ì¶œë ¥

```c++
void printLables(TreeNode* root) {
  cout << root->label << endl;
  for(int i=0; i<root->children.size(); ++i) {
    printLables(root->children);
  }
}
```

#### âŒ¨ï¸íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ì—¬ íŠ¸ë¦¬ì˜ ë†’ì´ ê³„ì‚°

```c++
int height(TreeNode* root) {
  int h=0;
  for(int i=0; i<root->children.size(); ++i) {//ë£¨íŠ¸ì˜ ìì‹ ìˆ˜ë§Œí¼
    //root->children[i] : ë£¨íŠ¸ì˜ ië²ˆì§¸ ìì‹
    h = max(h, 1 + height(root->children[i]));
  }
  return h;
}
```

### ğŸ“ì˜ˆì œ::íŠ¸ë¦¬ ìˆœíšŒ ìˆœì„œ ë³€ê²½(ID: TRAVERSAL)

**ë¬¸ì œ** : ì „ìœ„ìˆœíšŒí–ˆì„ ë•Œ ë…¸ë“œë°©ë¬¸ìˆœì„œ(preorder)ì™€ ì¤‘ìœ„ìˆœíšŒí–ˆì„ ë•Œ ë…¸ë“œë°©ë¬¸ìˆœì„œ(inorder)ê°€ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ íŠ¸ë¦¬ë¥¼ í›„ìœ„ìˆœíšŒí–ˆì„ ë•Œ ë…¸ë“œë“¤ì˜ ë°©ë¬¸ìˆœì„œë¥¼ ì¶œë ¥.

âš¡ï¸**keypoint**âš¡ï¸

1. ì „ìœ„ìˆœíšŒ ì‹œ, ì²˜ìŒìœ¼ë¡œ ë°©ë¬¸í•˜ëŠ” ë…¸ë“œê°€ ê·¸ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ë…¸ë“œì´ë‹¤. 
2. ì¤‘ìœ„ìˆœíšŒ ì‹œ, ë£¨íŠ¸ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì „ì— ë°©ë¬¸í•œ ë…¸ë“œë“¤ì€ ë£¨íŠ¸ë³´ë‹¤ ì‘ì€ ê°’ì„ ê°€ì§€ë©°, ì´í›„ì— ë°©ë¬¸í•œ ë…¸ë“œë“¤ì€ ë£¨íŠ¸ë³´ë‹¤ í° ê°’ì„ ê°€ì§„ë‹¤. 
3. ê·¸ëŸ¬ë¯€ë¡œ preorder[0]ì´ rootnodeì„ì„ ì €ì¥í•˜ê³ , inorderì—ì„œ rootnodeì˜ ìœ„ì¹˜ë¥¼ ì°¾ì€ í›„, ì¬ê·€í˜¸ì¶œì„ ì´ìš©í•´ í›„ìœ„ìˆœíšŒë¥¼ í•˜ë©´ëœë‹¤. 

ğŸ”‘**í•´ë‹µ(ì½”ë“œ)**ğŸ”‘

```c++
/*
 * ë°°ì—´ vë¥¼ êµ¬ê°„ [a,b]ë¡œ ìª¼ê°œëŠ” í•¨ìˆ˜
 * @param v [ìª¼ê°œë ¤ëŠ” ë°°ì—´(íŠ¸ë¦¬)]
 * @param a [ì‹œì‘êµ¬ê°„]
 * @param b [ëêµ¬ê°„]
 */
vector<int> slice(const vector<int>& v, int a, int b) {
  return vector<int>(v.begin()+a, v.begin()+b);
}
```

```c++
void printPostOrder(const vector<int>& preorder, const vector<int>& inorder) {
  const int N = preorder.size();
  if(preorder.empty()) return;
  const int root = preorder[0];
  const int L = find(inorder.begin(), inorder.end(), root) - inorder.begin();
  const int R = N - 1 - L;
  printPostOrder(slice(preorder, 1, L+1), slice(inorder, 0, L));
  printPostOrder(slice(preorder, L+1, N), slice(inorder, L+1, N));
  cout<<root<<' ';
}
```

_____________

## [ì¢…ë§Œë¶] ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(BST)

- ê²€ìƒ‰ íŠ¸ë¦¬ëŠ” ìë£Œë“¤ì„ **ì¼ì •í•œ ìˆœì„œ**ì— ë”°ë¼ ì •ë ¬ëœ ìƒíƒœë¡œ ì €ì¥í•œë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì›ì†Œì˜ ì¶”ê°€/ì‚­ì œ ì—°ì‚°ê³¼ íŠ¹ì •ì›ì†Œë¥¼ ì°¾ëŠ” ì—°ì‚°ì´ ë§¤ìš° ë¹ ë¥´ê²Œ ë™ì‘í•œë‹¤. 
- ì´ì§„íŠ¸ë¦¬ì˜ ì •ì˜ : ìµœëŒ€ ë‘ ê°œì˜ ìì‹ë…¸ë“œë¥¼ ê°–ëŠ” íŠ¸ë¦¬ 
- ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ì¤‘ìœ„ ìˆœíšŒí•˜ë©´ í¬ê¸° ìˆœì„œë¡œ ì •ë ¬ëœ ì›ì†Œì˜ ëª©ë¡ì„ ì–»ëŠ”ë‹¤. ì¦‰, ìµœëŒ€ì›ì†Œì™€ ìµœì†Œì›ì†Œë¥¼ ì‰½ê²Œ ì–»ì„ ìˆ˜ ìˆë‹¤. **ì¤‘ìœ„ìˆœíšŒ ì‹œ ê°€ì¥ ì²«ë²ˆì§¸ë¡œ ë°©ë¬¸í•˜ëŠ” ë…¸ë“œëŠ” ìµœì†Œê°’ì„, ê°€ì¥ ë§ˆì§€ë§‰ì— ë°©ë¬¸í•˜ëŠ” ë…¸ë“œëŠ” ìµœëŒ€ê°’ì„ ê°–ëŠ”ë‹¤. **
- **íŠ¸ë¦½(Treap)** : ì£¼ì–´ì§„ ê°’ Xë³´ë‹¤ ì‘ì€ ì›ì†Œì˜ ìˆ˜, í˜¹ì€ (í¬ê¸°ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì—ˆë‹¤ê³  ê°€ì •) k-ë²ˆì§¸ ì›ì†Œë¥¼ ì°¾ëŠ” ì—°ì‚°ë“¤ì„ ìˆ˜í–‰í•˜ëŠ”ë° ì‚¬ìš©í•œë‹¤. 
- ê· í˜• ì¡íŒ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬(balanced BST) : íŠ¸ë¦¬ì˜ ë†’ì´ê°€ í•­ìƒ **O(lgN)**ì´ ë˜ë„ë¡ í•˜ëŠ” íŠ¸ë¦¬. (ex. ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬_Red-Black Tree)

### ğŸ“ì˜ˆì œ::ë„ˆë“œì¸ê°€, ë„ˆë“œê°€ ì•„ë‹Œê°€? 2 (ID: NERD2)

**ë¬¸ì œ** : ë„ˆë“œì§€ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” ê¸°ì¤€ì€ 1. í‘¼ ë¬¸ì œì˜ ìˆ˜/ 2. ìƒˆë²½ì— ë¨¹ì€ ë¼ë©´ê·¸ë¦‡ìˆ˜ ì´ë‹¤. ë§Œì•½ íƒ€ ì°¸ê°€ìë³´ë‹¤ í‘¼ ë¬¸ì œì˜ ìˆ˜ê°€ ì ê³ , ìƒˆë²½ì— ë¨¹ì€ ë¼ë©´ ê·¸ë¦‡ ìˆ˜ê°€ ì ë‹¤ë©´ ì´ ì‚¬ëŒì€ ëŒ€íšŒìê²©ì´ ì—†ë‹¤ê³  íŒë‹¨í•œë‹¤. ì´ ë•Œ, ê° ì‚¬ëŒì´ ì°¸ê°€ì‹ ì²­ì„ í•  ë•Œë§ˆë‹¤ ëŒ€íšŒì— ì°¸ê°€í•  ìˆ˜ ìˆëŠ” ì‚¬ëŒë“¤ì˜ ìˆ˜ê°€ ì–´ë–»ê²Œ ë³€í•˜ëŠ”ì§€ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ ì‘ì„±.

âš¡ï¸**keypoint**âš¡ï¸

1. map<int, int>ë¥¼ ì´ìš©í•´ ê· í˜•ì¡íŒ BSTë¥¼ êµ¬í˜„í•œë‹¤. 
2. lower_bound(x) ëŠ” xì´ìƒì˜ ê°’ ì¤‘ ê°€ì¥ ì‘ì€ ê°’ì„ ë°˜í™˜í•˜ëŠ” STLì´ë‹¤. 
3. ë§Œì•½ ìƒˆ ì°¸ê°€ìì˜ xì¢Œí‘œ(ë¬¸ì œ ìˆ˜)ê°’ì˜ lower_boundë¥¼ ê°€ì§€ëŠ” ì°¸ê°€ì Kê°€ ìƒˆ ì°¸ê°€ìë¥¼ ì§€ë°°í•œë‹¤ë©´, ê·¸ë³´ë‹¤ í° xì¢Œí‘œë¥¼ ê°–ëŠ” ì°¸ê°€ìì™€ëŠ” ë¹„êµí•  í•„ìš”ê°€ ì—†ë‹¤. ì™œëƒí•˜ë©´ ì¢Œí‘œì˜ ìš°ì¸¡ìœ¼ë¡œ ê°ˆìˆ˜ë¡ yì¢Œí‘œê°’ì€ ì‘ì•„ì§€ê³ , xì¢Œí‘œê°’ì€ ì»¤ì§€ê¸° ë•Œë¬¸ì´ë‹¤. 

ğŸ”‘**í•´ë‹µ(ì½”ë“œ)**ğŸ”‘

```c++
map<int,int> coords; //ê° ì°¸ê°€ìë“¤ì˜ ë°ì´í„°(x,y)

bool isDominated(int x, int y) {
  map<int,int>::iterator it = coords.lower_bound(x);
  if(it == coors.end()) return false;
  return y < it->second;
}
```

```c++
void removeDominated(int x, int y) {
  map<int,int>::iterator it = coords.lower_bound(x);
  if(it == coords.begin()) return;
  --it;
  while(true) {
    if(it->second > y) break;
    if(it == coords.begin()) {
      coords.erase(it);
      break;
    }
    else {
      map<int,int>::iterator jt = it;
      --jt;
      coords.erase(it);
      it = jt;
    }
  }
}
```

```c++
int registered(int x, int y) {
  if(isDominated(x,y)) return coords.size();
  removeDominated(x,y);
  coords[x] = y;
  return coords.size();
}
```

**â±Time-Complexityâ±**

**O(N lgN)**

