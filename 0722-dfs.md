# 2020.07.22 Wed

**ğŸ“šê³µë¶€í•œ ê±° List**ğŸ“š

- ì¢…ë§Œë¶ - 28. ê·¸ë˜í”„ì˜ ê¹Šì´ ìš°ì„  íƒìƒ‰

-----

## [ì¢…ë§Œë¶] ê·¸ë˜í”„ì˜ ê¹Šì´ ìš°ì„  íƒìƒ‰

**DFS_Depth First Search**

#### âŒ¨ï¸ê·¸ë˜í”„ì˜ ê¹Šì´ ìš°ì„  íƒìƒ‰

```c++
vector<vector<int>> adj;
vector<bool> visited;

void dfs(int here) {
  visited[here] = true;
  for(int i=0; i<adj[here].size(); ++i) {
    int there = adj[here][i];
    if(!visited[there]) dfs(there);
  }
}

void dfsAll() {
  visited = vector<int>(adj.size(), false);
  for(int i=0; i<adj.size(); ++i) {
    if(!visited[i]) dfs(i);
  }
}
```

**Time/Space Complexity**

ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° : **O(|V|+|E|)**

ì¸ì ‘ í–‰ë ¬ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° : **O(|V|^2)**

í¬ì†Œí–‰ë ¬(spare matrix)ì¸ ê²½ìš°ì—ëŠ” ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼, ë°€ì§‘í–‰ë ¬(dense matrix)ì¸ ê²½ìš°ì—ëŠ” ì¸ì ‘ í–‰ë ¬ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê³µê°„ì˜ ë‚­ë¹„ë¥¼ ì¤„ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ë‹¤. 

### ìœ„ìƒì •ë ¬

ì˜ì¡´ì„± ê·¸ë˜í”„(Dependency Graph) : ê° ì‘ì—…ì„ ì •ì ìœ¼ë¡œ í‘œí˜„í•˜ê³  ì‘ì—… ê°„ì˜ ì˜ì¡´ ê´€ê³„ë¥¼ ê°„ì„ ìœ¼ë¡œ í‘œí˜„í•œ ë°©í–¥ ê·¸ë˜í”„

DAG : ì‚¬ì´í´ ì—†ëŠ” ë°©í–¥ ê·¸ë˜í”„. 

DAGì˜ ì •ì ì„ ë°°ì—´í•˜ëŠ” ë¬¸ì œë¥¼ ìœ„ìƒì •ë ¬(Topological Sort)ë¼ê³  í•œë‹¤. 

dfs()ê°€ ì¢…ë£Œë  ë•Œë§ˆë‹¤ ì •ì ì˜ ë²ˆí˜¸ë¥¼ ì €ì¥í•´ë‘ê³ , dfsAll()ì´ ì¢…ë£Œí•œ ë’¤ ê¸°ë¡ëœ ì •ì ë“¤ì˜ ìˆœì„œë¥¼ ë’¤ì§‘ìœ¼ë©´ ìœ„ìƒì •ë ¬ì˜ ê²°ê³¼ê°€ ëœë‹¤. 

### ğŸ“ì˜ˆì œ::ê³ ëŒ€ì–´ ì‚¬ì „(ID: DICTIONARY)

ë¬¸ì œ : ë‹¨ì–´ë“¤ì˜ ëª©ë¡ì´ ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§ˆ ë•Œ ì´ ì–¸ì–´ì—ì„œ ì•ŒíŒŒë²³ì˜ ìˆœì„œë¥¼ ê³„ì‚°.

âš¡ï¸**keypoint**âš¡ï¸

1. ê° ì•ŒíŒŒë²³ì„ ì •ì ìœ¼ë¡œ í‘œí˜„í•˜ê³ , ìˆœì„œëŠ” ë°©í–¥ê·¸ë˜í”„ë¡œ í‘œí˜„í•œë‹¤. 
2. ì‚¬ì´í´ì´ ìˆë‹¤ë©´ ìœ„ìƒì •ë ¬ì´ ì•„ë‹ˆë‹¤. ì‚¬ì´í´ì˜ ìœ ë¬´ë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì€ ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ê°„ì„ ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ë©´ëœë‹¤. 

ğŸ”‘**í•´ë‹µ(ì½”ë“œ)**ğŸ”‘

```c++
/*
 * ê³ ëŒ€ì–´ ì‚¬ì „ ë¬¸ì œì˜ ê·¸ë˜í”„ ìƒì„±
 */
vector<vector<int>> adj;
void makeGraph(const vector<string>& words) {
  adj = vector<vector<int>>(26,vector<int>(26,0));
  for(int i=1; i<words.size(); ++i) {
    int j=i-1, len = min(words[i].size(), words[j].size());
    for(int k=0; k<len; ++k) {
      if(words[i][k] != words[j][k]){
        int a = words[i][k] - 'a';
        int b = words[j][k] - 'a';
        adj[a][b] = 1;
        break;
      }
    }
  }
}
```

```c++
//ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ì´ìš©í•œ ìœ„ìƒì •ë ¬
vector<int> visited, order;
void dfs(int here) {
  visited[here] = 1;
  for(int there = 0; there<adj.size(); ++there) {
    if(adj[here][there] && !visited[there]) dfs(there);
  }
  order.push_back(here);
}

vector<int> topologicalSort() {
  visited = vector<int>(adj.size(), false);
  order.clear();
  for(int i=0; i<adj.size(); ++i) {
    if(!visited[i]) dfs(i);
  }
  //#include <algorithm>
  reverse(order.begin(), order.end());
  for(int i=0; i<adj.size(); ++i) {
    for(int j=i+1; j<adj.size(); ++j) {
      if(adj[order[j]][order[i]]) return vector<int>();
    }
  } 
  return order;
}
```

### ì˜¤ì¼ëŸ¬ ì„œí‚·(Euler Circuit)

ê·¸ë˜í”„ì˜ ëª¨ë“  ê°„ì„ ì„ ì •í™•íˆ í•œ ë²ˆì”© ì§€ë‚˜ì„œ ì‹œì‘ì ìœ¼ë¡œ ëŒì•„ì˜¤ëŠ” ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œ

- ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ë“¤ì´ ì§ìˆ˜ì ì´ì–´ì•¼ë§Œ ì˜¤ì¼ëŸ¬ ì„œí‚·ì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤. 
- `findRandomCircuit(u)` : ì •ì  uì—ì„œ ì‹œì‘í•´ ì•„ì§ ë”°ë¼ê°€ì§€ ì•Šì€ ê°„ì„  ì¤‘ í•˜ë‚˜ë¥¼ ë”°ë¼ê°€ë©° ì„ì˜ì˜ ê²½ë¡œë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜/ë”ì´ìƒ ë‚¨ì€ ê°„ì„ ì´ ì—†ì„ë•Œê¹Œì§€.

#### âŒ¨ï¸ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ì´ìš©í•œ ì˜¤ì¼ëŸ¬ ì„œí‚· ì°¾ê¸° ğŸ’¦

```c++
vector<vector<int>> adj;
void getEulerCircuit(int here, vector<int>& circuit) {
  for(int there=0; there<adj[here].size(); ++there) {
    while(adj[here][there]>0){
      adj[here][there]--;
      adj[there][here]--;
      getEulerCircuit(there, circuit);
    }
  }
  circuit.push_back(here);
}
```

